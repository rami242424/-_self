<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    
</body>
<script>
    // <화살표함수>
    /* const 함수명 = (파라미터) => {
        return 파라미터*2;
    }
    const 함수명2 = (파라미터) => 파라미터*2
    


    const 함수명 = (파라미터) => {
        return 파라미터*2;
    }
    const 함수명2 = (파라미터) => 파라미터*2
    console.log([1,2,3,4,5].map((파라미터)=>파라미터*2)) */


    // <클로저함수>
    - a 가 함수() 실행전에 선언되지 않거나 없어지면 오류가 발생한다.

    - 전역이 아닌 함수만이 변수를 기억하게 하는 방법이 필요하다.

    const a=1;

    function 함수() {
        console.log(a); // 1
    }

    함수();
    - 함수를 만드는 함수() 내부에 있는 함수() 가 클로저

    - 함수가 실행되고 종료되면 함수를만드는함수() 가 날란다.

    - 그걸 지켜주기 위해 클로저를 쓴다.

    // 클로저 -> 격리된 환경

    function 함수를만드는함수(x) {
        const a=1;
        function 함수() {
            console.log(x);
        }
        return 함수;
    }
    const 함수를만드는함수를통해만든함수 = 함수를만드는함수(3); // 함수()가 리턴되어 들어감
    함수를만드는함수를통해만든함수();
    - 함수가 실행되나면 날아간다는 것은 함수 종료 후 코드블럭의 변수와 내부의 함수가 메모리에서 사라짐

    - 가비지 컬렉터가 메모리를 회수한다.

    - 코드 블럭의 내부는 '함수를만드는함수를통해만든함수' (새로운 변수)에 들어가게 된다.

    - 새로운 변수는 코드 블럭을 가두고 혼자 쓰기 위해 가져간다.

    - 클로저는 격리된 환경 (닫힌것)

    - 함수를만드는함수()는 종료 후 내부함수와 변수값은 메모리에서 지워진다. 하지만 새로운 변수가 return으로
    반환되는 내부함수 클로저를 참조하고, 클로저가 변수값을 참조하면서 연결된 것들은 메모리에서 지워지지
    않도록 붙잡는다.

    - 다시말해, 클로저는 새로 할당된 변수에서 참조하고 있어서 사라지지 않고 x까지 붙들고 있다. (클로저 형성)

    - 다른 변수에 넣어 사용하면 클로저는 계속 생성된다.

    // 클로저 -> 격리된 환경

    function 함수를만드는함수(x) {

        function 함수() {
            console.log(x);
        }
        return 함수;
    }
    const 함수를만드는함수를통해만든함수 = 함수를만드는함수(3); // 함수()가 리턴되어 들어감
    함수를만드는함수를통해만든함수(); // 함수가 사라져도 값 3을 가져올 수 있다.

    const 함수를만드는함수를통해만든함수2 = 함수를만드는함수(2); // 함수()가 리턴되어 들어감
    함수를만드는함수를통해만든함수2(); // 함수가 사라져도 값 2을 가져올 수 있다.
    </script>
</html>